---
title: "任务二-逻辑回归算法梳理"
categories: "初级算法梳理"
tags:
  - ML
comments: true
date: 2019-03-03 19:32:00
---

# 逻辑回归与线性回归的联系与区别

<!--more-->

1. 逻辑回归是一个非线性模型，sigmoid函数又称逻辑回归函数。
1. 线性回归要求变量服从正态分布，logistic回归对变量分布没有要求。线性回归要求因变量是连续性数值变量，logistic回归要求因变量是分类型变量。线性回归要求自变量和因变量呈线性关系，而logistic回归不要求自变量和因变量呈线性关系。
1. 线性回归中使用的是最小化平方误差损失函数，对偏离真实值越远的数据惩罚越严重；逻辑回归使用对数似然函数进行参数估计，使用交叉熵作为损失函数，对预测错误的惩罚是随着输出的增大，逐渐逼近一个常数
1. 逻辑回归以及线性回归同属于广义线性模型(generalized linear model)，不同的就是因变量不同，如果是连续的，就是多重线性回归，如果是二项分布，就是logistic回归。logistic回归的因变量可以使二分类的，也可是多分类的。

# 逻辑回归的原理

线性回归可以预测连续值，但是不能解决分类问题，我们需要根据预测的结果判定其属于正类还是负类。所以逻辑回归就是将线性回归的(−∞,+∞) 的结果通过 sigmiod 函数映射到0与1之间从而实现分类。

# 逻辑回归损失函数推导及优化

**逻辑回归**：

$h(x)  = \frac{1} {1 + e^{-(w^Tx+b)}}$
设$y_i$=1的概率为$p_i$，$y_i$=0的概率为$1-p_i$
则观测概率：
$p(y_i) = p_i^{y_i}(1-p_i)^{1-y_i}$
概率由逻辑回归公式求解，带进去得到极大似然函数：
$\prod_i^N h(x_i)^{y_i} * (1-h(x_i))^{1-y_i}$

# 正则化与模型评估指标

## 正则化

正则化就是在损失函数后加上一个正则化项（惩罚项），其实就是常说的结构风险最小化策略，即经验风险（损失函数）加上正则化。一般模型越复杂，正则化值越大。
正则化是用来对模型中某些参数进行约束，目的是防止过拟合。

## 评估指标

### 分类模型

1. 准确率（Accuracy）
1. 精确率（Precision）
1. 召回率（Recall）
1. $F_1$-score(精确率和召回率的调和平均)
1. AUC（ROC曲线下面积）

### 回归模型

1. 平方根误差（RMSE）
1. 误差分位数（Quantiles of Errors）

# 逻辑回归的优缺点

* 优点：
  1. 适合二分类问题
  1. 计算代价不高，容易理解实现。可用于分布式计算
  1. LR对于数据中小噪声的鲁棒性很好，并且不会受到轻微的多重共线性的特别影响。（L2正则化可帮助解决）

* 缺点：
  1. 容易欠拟合，分类精度不高。
  1. 数据特征有缺失或者特征空间很大时表现效果并不好。
  1. 只能解决二分类问题（softmax除外）

# 样本不均衡问题解决办法

## 过采样

将稀有类别的样本进行复制，通过增加此稀有类样本的数量来平衡数据集。该方法适用于数据量较小的情况。

### 欠采样

从丰富类别的样本中随机选取和稀有类别相同数目的样本，通过减少丰富类的样本量啦平衡数据集。该方法适用于数据量较大的情况。

### SMOTE构造采样

基于距离度量的方式计算两个或多个稀有类样本之间的相似性。然后选择其中的一个样本作为基础样本，再在邻居样本中随机选取一定数量的样本对那个基础样本的一个属性进行噪声。每次处理一个属性，通过这样的方式产生新生数据。

### 对原数据的权值进行改变

通过改变多数类样本和少数类样本数据在训练时的权重来解决样本不均衡的问题，是指在训练分类器时，为少数类样本赋予更大的权值，为多数类样本赋予较小的权值。  

### 通过组合集成方法解决

将多数类数据随机分成少数类数据的量N份，每一份与全部的少数类数据一起训练成为一个分类器，这样反复训练会生成很多的分类器。最后再用组合的方式(bagging或者boosting)对分类器进行组合，得到更好的预测效果。简单来说若是分类问题可采用投票法，预测问题可以采用平均值。这个解决方式需要很强的计算能力以及时间，但效果较好，相当于结合了组合分类器的优势。

### 通过特征选择

在样本数据较为不均衡，某一类别数据较少的情况下，通常会出现特征分布很不均衡的情况。例如文本分类中，有大量的特征可以选择。因此我们可以选择具有显著区分能力的特征进行训练，也能在一定程度上提高模型的泛化效果。

# sklearn参数

**Sklearn.linear_model.**
penalty:’l1’ or ‘l2’ ,默认’l2’ #惩罚

dual:bool 默认False ‘双配方仅用于利用liblinear解算器的l2惩罚。’

tol: float, 默认: 1e-4 ‘公差停止标准’

C:float 默认:1.0 正则化强度， 与支持向量机一样，较小的值指定更强的正则化。

fit_intercept: bool 默认:True 指定是否应将常量（a.k.a. bias或intercept）添加到决策函数中。

intercept_scaling:float ,默认:1 仅在使用求解器“liblinear”且self.fit_intercept设置为True时有用。 在这种情况下，x变为[x，self.intercept_scaling]，即具有等于intercept_scaling的常数值的“合成”特征被附加到实例矢量。 截距变为intercept_scaling * synthetic_feature_weight

class_weight: dict or ‘balanced’ 默认:None

 与{class_label：weight}形式的类相关联的权重。 如果没有给出，所有类都应该有一个权重。“平衡”模式使用y的值自动调整与输入数据中的类频率成反比的权重，如n_samples /（n_classes * np.bincount（y））。请注意，如果指定了sample_weight，这些权重将与sample_weight（通过fit方法传递）相乘。

random_state:int,RandomState实例或None，可选，默认值：None

在随机数据混洗时使用的伪随机数生成器的种子。 如果是int，则random_state是随机数生成器使用的种子; 如果是RandomState实例，则random_state是随机数生成器; 如果为None，则随机数生成器是np.random使用的RandomState实例。 在求解器=='sag'或'liblinear'时使用。

# 参考资料

西瓜书

cs229吴恩达机器学习课程

李航统计学习

谷歌搜索